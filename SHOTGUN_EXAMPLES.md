# Shotgun-Style Implementation Examples

This document demonstrates how to use the Repo-to-Text MCP Server's powerful task generation features, similar to Shotgun but with AI-powered intelligence.

## Overview

The implementation generation workflow allows you to:
1. Describe what you want to build
2. Get a comprehensive Gemini prompt with your entire codebase context
3. Parse Gemini's response into IDE-specific directives
4. Execute the implementation step-by-step

## Example 1: Adding Authentication to Express App

### Step 1: Analyze the Project
```
User: Analyze my Express project at /Users/dev/myapp
Claude: # Project Analysis

## Overview
- **Total Files**: 142
- **Root Path**: /Users/dev/myapp
- **Detected Type(s)**: node, express

## File Types Distribution
- **.js**: 89 files
- **.json**: 12 files
- **.md**: 8 files
...
```

### Step 2: Generate Implementation Tasks
```
User: Generate implementation tasks for /Users/dev/myapp with requirements:
"Add complete JWT-based authentication system with:
- User registration and login endpoints
- Email/password authentication
- Secure password hashing with bcrypt
- JWT token generation and refresh tokens
- Protected route middleware
- User profile CRUD operations
- Password reset functionality
- Rate limiting for auth endpoints"
```

### Step 3: Get Gemini Prompt
The tool generates a comprehensive prompt including:
- Your entire codebase in XML format
- Project structure analysis
- Detailed requirements
- Task complexity assessment

```
Claude: # Generated Implementation Task Prompt

## Instructions for Gemini 2.5 Pro
Copy this prompt to Gemini 2.5 Pro to generate complete implementation directives:

[Full prompt with ~50,000 tokens of context]

## Project Stats:
- Context size: ~48,532 tokens
- Project type: node, express
- Task complexity: complex
```

### Step 4: Use with Gemini 2.5 Pro
Copy the generated prompt to Gemini and ask for implementation.

### Step 5: Parse Gemini's Response
```
User: Parse this Gemini response for Cursor:

"## Overview
This implementation adds a complete JWT-based authentication system to your Express application...

## Architecture Changes
1. Create new directory structure:
   - `/middleware/auth.js` - Authentication middleware
   - `/models/User.js` - User model with Mongoose
   - `/routes/auth.js` - Authentication routes
   - `/utils/jwt.js` - JWT utility functions
   - `/utils/email.js` - Email service for password reset

## Implementation Steps

### Step 1: Install Required Dependencies
```bash
npm install jsonwebtoken bcrypt express-validator express-rate-limit
npm install nodemailer crypto-random-string
npm install --save-dev @types/jsonwebtoken @types/bcrypt
```

### Step 2: Create User Model
Create `models/User.js`:
```javascript
const mongoose = require('mongoose');
const bcrypt = require('bcrypt');

const userSchema = new mongoose.Schema({
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true,
    trim: true
  },
  password: {
    type: String,
    required: true,
    minlength: 6
  },
  refreshTokens: [{
    token: String,
    createdAt: {
      type: Date,
      default: Date.now,
      expires: 604800 // 7 days
    }
  }],
  resetPasswordToken: String,
  resetPasswordExpires: Date,
  createdAt: {
    type: Date,
    default: Date.now
  }
});

// Hash password before saving
userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  
  try {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error);
  }
});

// Compare password method
userSchema.methods.comparePassword = async function(candidatePassword) {
  return bcrypt.compare(candidatePassword, this.password);
};

module.exports = mongoose.model('User', userSchema);
```
[... continue with more implementation details ...]"
```

### Step 6: Get Formatted Directives

```
Claude: # üéØ CURSOR IMPLEMENTATION DIRECTIVES
# Auto-generated by Repo-to-Text MCP Server (Shotgun Mode)
# Generated: 2024-12-29 10:30:00

## üìã TASK OVERVIEW
This implementation adds a complete JWT-based authentication system to your Express application...

## üèóÔ∏è ARCHITECTURE CHANGES
- Create new directory structure for auth components
- Add User model with secure password handling
- Implement JWT token management with refresh tokens
- Add email service for password reset
- Set up rate limiting for security

## üìù IMPLEMENTATION STEPS

### Step 1
Install Required Dependencies
```bash
npm install jsonwebtoken bcrypt express-validator express-rate-limit nodemailer crypto-random-string
```

### Step 2
Create User Model at `models/User.js`
[Full code implementation with explanations]

### Step 3
Create JWT Utilities at `utils/jwt.js`
[Full code implementation]

### Step 4
Create Authentication Middleware at `middleware/auth.js`
[Full code implementation]

### Step 5
Create Authentication Routes at `routes/auth.js`
[Full code implementation]

### Step 6
Update Main App File
[Integration code]

## üìÅ FILE MODIFICATIONS

### New Files to Create:
1. `models/User.js` - User model with authentication methods
2. `middleware/auth.js` - JWT verification middleware
3. `routes/auth.js` - Authentication endpoints
4. `utils/jwt.js` - Token generation utilities
5. `utils/email.js` - Email service for password reset
6. `config/auth.js` - Authentication configuration

### Files to Modify:
1. `app.js` - Add auth routes and middleware
2. `package.json` - Update dependencies
3. `.env` - Add JWT_SECRET and email config

## üíª CODE EXAMPLES
[Complete, working code snippets for each component]

## üß™ TESTING STRATEGY
1. Unit tests for User model methods
2. Integration tests for auth endpoints
3. JWT token validation tests
4. Rate limiting tests
5. Password reset flow tests

[PROJECT CONTEXT FOLLOWS]
================================================================================
```

## Example 2: Adding Real-time Features with Socket.io

### Complete Workflow
```
User: Generate implementation plan for /Users/dev/chatapp with requirements:
"Add real-time messaging with Socket.io including:
- WebSocket connection management
- Room-based messaging
- Typing indicators
- Online user tracking
- Message delivery status
- File sharing support
- Message history with pagination"

Target IDE: windsurf
```

The server will:
1. Analyze your chat application structure
2. Generate a Gemini prompt with full context
3. Help you get implementation directives
4. Format everything for Windsurf's workflow

## Example 3: Refactoring to Microservices

### For Complex Architectural Changes
```
User: Generate implementation tasks for /Users/dev/monolith
Requirements: "Refactor monolithic app to microservices:
- Extract user service
- Extract payment service  
- Extract notification service
- Add API gateway
- Implement service discovery
- Add message queue for inter-service communication"
Task type: refactor
Complexity: architectural
```

This generates comprehensive architectural guidance with:
- Service boundaries identification
- Data migration strategies
- API contract definitions
- Deployment configurations
- Testing strategies

## Tips for Best Results

### 1. Be Specific with Requirements
Instead of: "Add authentication"
Use: "Add JWT authentication with refresh tokens, password reset via email, and OAuth2 Google login"

### 2. Specify Task Type
- `feature`: New functionality
- `refactor`: Code restructuring
- `bugfix`: Fixing issues
- `optimization`: Performance improvements
- `documentation`: Docs and comments
- `testing`: Test coverage

### 3. Set Appropriate Complexity
- `simple`: < 2 hours of work
- `moderate`: 2-8 hours
- `complex`: 1-3 days
- `architectural`: Major changes

### 4. Choose Right Target IDE
- `cursor`: Best for step-by-step implementation
- `windsurf`: Optimized for Windsurf workflow
- `claude-desktop`: Creates task breakdown
- `generic`: JSON format for any tool

## Advanced Usage

### Chaining Multiple Features
```
1. First, implement authentication:
   "Generate implementation plan for auth system..."

2. Then, add authorization:
   "Generate implementation tasks for role-based access control..."

3. Finally, add audit logging:
   "Generate implementation plan for audit trail..."
```

### Iterative Development
After implementing each part, you can:
1. Re-analyze the project to see changes
2. Generate next phase implementation
3. Maintain consistent architecture

## Comparison with Original Shotgun

| Feature | Original Shotgun | This MCP Server |
|---------|------------------|-----------------|
| Context Generation | ‚úì | ‚úì Enhanced with AI filtering |
| Task Creation | ‚úó | ‚úì AI-powered task generation |
| IDE Integration | Basic | ‚úì Multi-IDE support |
| Implementation Guide | ‚úó | ‚úì Step-by-step directives |
| Code Examples | ‚úó | ‚úì Complete code snippets |
| Architecture Planning | ‚úó | ‚úì Architectural guidance |
| Testing Strategy | ‚úó | ‚úì Test planning included |

## Troubleshooting

### "Context too large for Gemini"
- Use exclusions to reduce context size
- Focus on relevant parts of codebase
- Use chunking for very large projects

### "Gemini response not detailed enough"
- Add more specific requirements
- Increase complexity level
- Include examples in requirements

### "Directives not matching my IDE"
- Ensure correct target_ide is specified
- Try generic format and adapt manually
- Report specific formatting issues

## Best Practices

1. **Start with Analysis**: Always analyze project first
2. **Incremental Implementation**: Break large features into smaller tasks
3. **Review Generated Code**: AI suggestions need human review
4. **Test as You Go**: Implement testing alongside features
5. **Document Changes**: Keep track of architectural decisions

## Conclusion

This Shotgun-style implementation generator bridges the gap between your ideas and working code. By combining your codebase context with Gemini's understanding, it creates actionable implementation plans that save hours of planning and research.

Perfect for:
- Rapid prototyping
- Learning new patterns
- Consistent implementation
- Team collaboration
- Architecture planning